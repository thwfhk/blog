[{"authors":null,"categories":null,"content":"I am a third-year undergraduate student in the Department of Computer Science at Peking University. My research interests span generally in programming languages, especially type systems, functional programming, bidirectional transformation and program calculation.\nI am currently advised by Prof. Zhenjiang Hu and I am an intern in the Programing Language Group of Peking University.\n Download my resumé. -- ","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"thwfhk.github.io/author/wenhao-tang/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/author/wenhao-tang/","section":"authors","summary":"I am a third-year undergraduate student in the Department of Computer Science at Peking University. My research interests span generally in programming languages, especially type systems, functional programming, bidirectional transformation and program calculation.","tags":null,"title":"Wenhao Tang","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"thwfhk.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/talk/example/","section":"talk","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":[],"content":" 人的本质是一切社会关系的总和\n 这是一篇关于Category Theory in Context的第二章Universal Properties, Representability, and the Yoneda Lemma的学习笔记，记录了核心内容与一些个人理解。\nMotivation: 最基本的描述universal property的方式是：某个object是某个category的initial/terminal object。这种方式的问题在于需要构造复杂的category。我们希望有一种更方便的描述universal property的方式：通过representable functor来描述从c映射出/映射到c的所有映射的样子。\nRepresentable Functors 以下均假设\\(C\\) is locally small.\n[Def] \\(C\\) is locally small, \\(c\\in C\\),\n \\(C(c,-):C\\to Set\\)是 covariant functor represented by \\(c\\) \\(C(-,c):C^{op}\\to Set\\)是 contravariant functor represented by \\(c\\)    对于\\(f:x\\to y\\), \\(C(c,f) = f_* : C(c,x)\\to C(c,y)\\)是post-composition，\\(C(c,f) g = f g\\) 将f在g之后（左）作用上\n 对于\\(f:x\\to y\\) ,\\(C(f,c):C(y,c)\\to C(x,c)\\)是pre-composition，\\(C(-,c) f\\ g = gf\\)将f在g之前（右）作用上\n  [Def] two-sided represented functor \\(\\mathrm{C}(-,-): \\mathrm{C}^{\\mathrm{op}} \\times \\mathrm{C} \\rightarrow \\text { Set }\\)\n 对于\\(f:w\\to x, h:y\\to z\\)，\\(C(f,h):C(x,y)\\to C(w,z)\\)分别将f复合在g前，h复合在g后。\\(g:x\\to y\\)，\\(C(f,h)g = hgf\\)  [Def] Representable functor: \\(C\\) is locally small, \\(c\\in C\\),\n A covariant functor \\(F:C\\to Set\\) is representable if \\(C(c,-)\\cong F\\) A contravariant functor \\(F:C^{op}\\to Set\\) is representable if \\(C(-,c)\\cong F\\) 称\\(F\\) is represented by \\(c\\), \\(c\\)称为the representing object  Yoneda Lemma 为了用representable functor描述universal property，我们需要知道构造一个\\(C(c,-)\\cong F\\)需要什么？我们先看更一般的情况，构造\\(\\alpha : C(c,-)\\Rightarrow F\\)需要什么。Yoneda lemma告诉我们，只要给出一个\\(x\\in F\\ c\\)就可以构造出一个\\(\\alpha\\).\n[Thm] Yoneda lemma: \\(C\\) is locally small, 对于\\(c\\in C\\),\n \\(F:C\\to Set\\), 有双射\\(\\mathrm{Hom}(C(c,-),F)\\cong F\\ c\\), 且natural in \\(c\\) and \\(F\\). \\(F:C^{op}\\to Set\\), 有双射\\(\\mathrm{Hom}(C(-,c),F)\\cong F\\ c\\), 且natural in \\(c\\) and \\(F\\).  Remark:\n 理解：这个双射说明natural transformation \\(\\alpha:C(c,-)\\Rightarrow F\\) 与 \\(x\\in F\\ c\\) 之间的一一对应 从左到右，\\(\\alpha_c(1_c)\\)就是\\(F\\ c\\)中的一个元素 从右到左，给出\\(x\\in F\\ c\\)，再利用\\(\\alpha\\)的naturality就可以确定一个natural transformation \\(\\alpha\\). 实际上，给出的就是\\(\\alpha_c(1_c)\\). 双射具体构造： 从左到右 \\(\\Phi: \\operatorname{Hom}(\\mathrm{C}(c,-), F) \\rightarrow F c\\), \\(\\Phi(\\alpha):=\\alpha_{c}\\left(1_{c}\\right)\\) 从右到左 \\(\\Psi: F c \\rightarrow \\operatorname{Hom}(\\mathrm{C}(c,-), F)\\), \\(\\Psi(x)\\)就是某个natural transformatiton \\(\\alpha\\). \\(\\Psi(x)\\)定义为对于\\(f:c\\to d\\), \\(\\Psi(x)_d(f) = F f(x)\\). 构造的核心想法是在如下交换图中\\(1_c\\)的沿着两条路径计算结果相等，证明只要验证\\(\\Psi(x)\\)的naturality、$\\(是\\)$的逆以及整个双射natural in c and F.    一个关于size的问题：由于\\(C\\) is locally small, 由functor category部分的结论不能保证\\(Set^C\\) is locally small, 但是从Yoneda lemma可以得知\\(\\mathrm{Hom}(C(c,-),F)\\)（这是\\(Set^C\\)中两个objects之间的mophisms集合）确实是一个set.  Yoneda lemma的等价表述：\\(\\Phi : \\mathrm{Hom}(y(-),-)\\Rightarrow ev\\) is a natural isomorphism.\n 其中functor \\(y\\) 定义如下图所示    具体解释略  Yoneda Embedding Yoneda lemma的一个重要应用是Yoneda embedding，这可以告诉我们用universal property刻画的objects之间同构。\n[Thm] Yoneda embedding: \\(y\\) is a full and faithful embedding.\nRemark:\n 理解：以covariant Yoneda embedding为例，这说明\\(\\forall c,d\\in C\\), \\(C(c,d)\\)与\\(\\mathrm{Hom}(C(-,c),C(-,d))\\)之间有双射，并且该双射保持composition和identity（这是\\(y\\)的functoriality要求，无需证明）. 这个双射将\\(f\\)映射到\\(f_*\\). full and faithful embedding说明\\(C\\) is isomorphic to a full subcategory of \\(Set^{C^{op}}\\) 证明中，证明是满射用到了yoneda lemma  [Prop] Yoneda embedding的推论\n 若\\(x\\cong y\\), 则\\(C(x,-)\\cong C(y,-)\\)且\\(C(-,x)\\cong C(-,y)\\) 若\\(C(x,-)\\cong C(y,-)\\)或\\(C(-,x)\\cong C(-,y)\\)，则\\(x\\cong y\\)  Universal Property 有了之前的准备，就可以给出universal property的描述了！\n[Def] Universal property of \\(c\\in C\\)定义为：\n a reprensentable functor \\(F\\) a universal element \\(x\\in F c\\)  s.t. 它们通过Yoneda lemma给出了一个natural isomorphism \\(C(c,-)\\cong F\\) (F covariant)或者 \\(C(-,c)\\cong F\\) (F contravariant).\nRemark:\n 由Yoneda lemma，\\(x\\in F c\\)对应了一个natural transformation \\(\\alpha\\), 并且我们希望它是natural isomorphism. 这个\\(\\alpha : C(c,-)\\Rightarrow F\\)的定义如下： \\(\\alpha_c(1_c) = x\\) \\(f:c\\to d,\\ \\alpha_d(f) = F f(x)\\) 由Yoneda embedding的推论，\\(c\\)在同构意义下唯一 直观上，一个universal property of c刻画了c出/入映射的性质  这种universal property的描述与之前的描述有什么联系呢？下面我们想说明：一个universal element是某个category中的initial/terminal object.\n[Def] Category of elements\n 对于\\(F:C\\to Set\\), Category of elements \\(\\int F\\) objects：\\((c,x)\\) where \\(c\\in C,\\ x\\in F\\ c\\) morphisms: a morphism \\((c,x)\\to (c\u0026#39;,x\u0026#39;)\\) is a \\(f:c\\to c\u0026#39;\\) s.t. \\(F f(x)=x\u0026#39;\\) 对于\\(F:C^{op }\\to Set\\), Category of elements \\(\\int F\\) objects：\\((c,x)\\) where \\(c\\in C,\\ x\\in F\\ c\\) morphisms: a morphism \\((c,x)\\to (c\u0026#39;,x\u0026#39;)\\) is a \\(f:c\\to c\u0026#39;\\) s.t. \\(F f(x\u0026#39;)=x\\)  Remarks:\n 直观理解，\\(\\int F\\)把所有集合\\(F\\ c\\)中的元素拿出来作为objects  [Prop]\n \\(F:C\\to Set\\) is reprensentable iff \\(\\int F\\) has an initial element \\(F^{op}:C\\to Set\\) is reprensentable iff \\(\\int F\\) has an terminal element  Remark:\n 这个推论说明，initial element \\((c,x)\\in \\int F\\) 中的\\(x\\) 就是 universal property of \\(c\\)中的universal element \\(x\\)，也就是说它通过Yoneda lemma给出了一个natural isomorphism.\n a representation of \\(F\\) 是\\(c\\)和自然同构\\(C(c,-)\\cong F\\). 注意到这和initial object \\((c,x)\\in \\int F\\)等价，因此有时候也说a representation of \\(F\\) is the initial object in \\(\\int F\\).\n  例子 1. initial object 考虑initial object \\(c\\in C\\)的universal property，是constant functor \\(*:C\\to Set\\) (将任意\\(d\\in C\\)映射到singleton set \\(*\\))和universal element \\(x\\in *\\) (只有唯一一个元素)使得\\(C(c,-)\\cong *\\).\n\\((c,x)\\in \\int *\\) 是initial object实际上就是说\\(c\\in C\\)是initial object（因为x位置上只有x这一个元素）。\n2. 图染色 这个例子来自Category in Context, 我觉得这个例子很形象很CS。\n考虑functor \\(nColor：Graph^{op}\\to Set\\) 将图g映射到g的所有n染色方案的集合。\\(nColor\\)是contravariant的因为有了图同态\\(f:G\\to G\u0026#39;\\) ，利用图同构保持顶点相邻关系，可以从\\(G\u0026#39;\\)的染色方案得到\\(G\\)的染色方案。\n我们宣称完全图\\(K_n\\) represents \\(nColor\\), 也就是说\\(Graph(-,K_n)\\cong nColor\\). （这个自然同构非常直观，可以把映射到顶点n想象成染上颜色n）。\n此时，universal property of \\(K_n\\)就是：\n a representable functor \\(nColor\\) a universal element \\(x\\in nColor\\ K_n\\)  使得\\(x\\)由Yoneda lemma定义的natural transformation是个natural isomorphism.\n由于该问题的特殊性，\\(x\\)可以任取。\n考虑\\(\\int nColor\\), 里面的objects是\u0026quot;一个图+该图的一种染色方案=a n-colored graph\u0026quot;, morphisms是保持颜色的图同态。所以\\((c,x)\\)就是terminal n-colored graph.\n","date":1601373090,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601373090,"objectID":"326bc4f9acf6653d445e2d26f8ad8d4e","permalink":"thwfhk.github.io/post/yoneda_lemma/","publishdate":"2020-09-29T17:51:30+08:00","relpermalink":"thwfhk.github.io/post/yoneda_lemma/","section":"post","summary":" 人的本质是一切社会关系的总和\n","tags":["Category Theory"],"title":"万有性质和米田引理","type":"post"},{"authors":null,"categories":[],"content":" 某种意义上，高阶意味着一等公民（\n 在阅读PL相关的论文以及函数式语言的相关资料的时候，经常会看到\u0026quot;higher-order xxx\u0026ldquo;或者\u0026rdquo;higher-xxx yyy\u0026ldquo;这种格式的词语，仿佛是一切东西前面都能加个higher-order。我时常分不清他们的含义，于是我想从语言的角度总结一下各种higher/higher-order开头的词语。可以发现他们之间还是很相似的。\nHigher-order Functions higher-order function 指接受函数作为参数的函数（有时候返回函数的函数也算），比如map :: (a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; [b]。\n如果我们把type写成一棵语法树，可以对于higher-order function的type，它从根走到某个$(a\\to b)$的路径上至少有一次是走了某个$\\to$节点的左边。\n在支持higher-order function的语言中，函数是一等公民（first-class citizen），也就是说函数可以作为参数传递。严格来说一等公民还应该支持赋值、存储等操作，但我觉得已经支持作为参数传递和返回了，其他的应该也都支持（纯粹的函数式语言不在意这些🐶）。\n如果出现higher-order language这个词，一般指支持higher-order function的语言。\n对应的lambda calculus的例子：simply typed lambda calculus $\\lambda_\\to$.\nHigher-order Type (Operators) 首先简单介绍一下关于type operator和kind的前置知识：\n我们想要讨论type-level functions (or type operators, type constructors), 比如Ref T , Pair S T等等。因此在type层面引入了abstraction $\\lambda X::K.T$ 和application $T\\ T$。这样就有了type operators。\n为了从arity上区分type (operators)，我们引入kinds (the types of types):\n a single atomic kind $*$ (pronounced \u0026ldquo;type\u0026rdquo;) a single constructor $\\Rightarrow$  一些例子：\n $*$ : the kind of proper types (or ground types, the sorts of type expressions that are actually used to classify terms), like $Bool,\\ Nat\\to Nat,\\ \\forall X.X\\to X$ $*\\Rightarrow $ : the kind of type operators (functions from proper types to proper types), like $\\lambda X.T$ (abbreviation for $\\lambda X::.T$) $* \\Rightarrow * \\Rightarrow *$ : the kind of functions from proper types to type operators $(* \\Rightarrow *) \\Rightarrow *$ : the kind of functions from type operators to proper types.  有$*\\Rightarrow \\cdots \\Rightarrow *$ 这种kind的type称为type operator或者first-order type operator；\n而如果有$(*\\Rightarrow *)$出现在某个$\\Rightarrow$的左子树，这种type operator称为higher-order type operators or higher-kinded type operators。这个定义和higher-order function是完全一致的，别忘了type operator是type之间的function。\nhigher-order type operator很少出现。\n对应的lambda calculus的例子：$\\lambda_\\omega$\nHigher-rank Polymorphism Polymorphism有很多种，higher-rank polymorphism是对于parametric polymorphism来说的。\nParametric polymorphism允许在type中出现type variable和quantifier （如$\\lambda X.t :: \\forall X.T$），并在evaluation时用不同的type实例化type variable。他与ad-hoc polymorphism的很大一个不同在于：The polymorphic functions act on different types uniformly. 这也是parametricity(see theorem for free)的来源。\n一些例子：System $F$，FP中大部分语言，面向对象中的generics，C++中的template。\n几种分类：\n let-polymorphsim(prenex polymorphism): 只允许polymorphism出现在top-level let-bindings，也就是说quantifier只能出现在最外层，因此type variables只能instantiate成quntifier-free type。又称为rank-1 polymorphism. rank-2 polymorphism: 把type写成语法树树，从根到任一个$\\forall$ quantifier的路径不走两次或以上$\\to$节点的左边。比如$(\\forall X.X\\to X)\\to Nat$就是走了一次。 rank-k polymorphism (如上类推) rank-n polymorphism又称为higher-rank polymorphism or impredicative (first-class) polymorphism，允许任意多次。注意到，此时我们可以将polymorphic function任意的当作参数进行传递，因此polymorphic function变成了一等公民。  Haskell支持rank-n polymorphism，{-# LANGUAGE Rank2Types #-} {-# LANGUAGE Rank2Types #-}实际上就是用来开启rank-n polymorphism. 这样就可以写出f :: (forall n. n-\u0026gt;n) -\u0026gt; (Int, Double)这种函数。注意它与f :: forall n . (n-\u0026gt;n) -\u0026gt; (Int, Double)的区别：前者接受一个能作用于任意类型n并返回类型n的函数，后者接受的函数中n是任意一个具体的类型了。\n对应的lambda calculus的例子：polymorphic lambda calculus $F$ (System F)\n 值得注意的是，Haskell的function并不支持explicit type-level abstraction（而System F中支持），因为这会使type inference变成undecidable。Haskell的编译器会自动推断type variable应该实例化成哪个类型。\n在加入pragma{-# language TypeApplications #-}后可以写出idInt = id @Int\n Higher-order Polymorphism higher-order polymorphism or higher-kinded polymorphism也是对于parametric polymorphism来说的，就是将前两节提到的higher-kinded type与higher-rank polymorphism结合到一起，允许parametric polymorphism的type variable遍历type operator。\n例如：\ntype Ground = Int type FirstOrder a = Maybe a -- a is ground type SecondOrder c = c Int -- c is a first-order constructor type ThirdOrder c = c Maybe -- c is second-order  Haskell中fmap :: forall f. Functor f =\u0026gt; (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f b，f :: *-\u0026gt;*是一个type operator，所以这是个higher-order polymorphism。这个例子中只用到了rank-1 polymorphism，我们也可以写出同时用到rank-2 polymorphism和higher-order polymorphism的例子：ret :: Monad m' =\u0026gt; (forall m. Monad m =\u0026gt; a -\u0026gt; m a) -\u0026gt; a -\u0026gt; m' a。\n对应的lambda calculus的例子：Higher-order polymorphic lambda-calculus $F_\\omega$\n后记 本来想写parametricity结果发现坑越来越大，于是水点简单的东西。\n希望有时间去认真学一下他们与logic的联系。\n","date":1598348622,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598348622,"objectID":"e5a5ea55cdc62146945075543ea85f9a","permalink":"thwfhk.github.io/post/higher_order_xxx/","publishdate":"2020-08-25T17:43:42+08:00","relpermalink":"thwfhk.github.io/post/higher_order_xxx/","section":"post","summary":" 某种意义上，高阶意味着一等公民（\n","tags":["Haskell","Programming Language Theory"],"title":"区分一些Higher-order开头的词","type":"post"},{"authors":null,"categories":[],"content":" All told, monad is just a monoid in the category of endofunctors.\n 连鸽两个月后终于在八月份的末尾再次更新（填坑）。\n寒假的时候写过一个关于“Haskell中monad与范畴论有什么联系”的文章，当时写得很naive，现在了解的更多了一点，于是决定重写一下。主要参考资料是Category Theory for Programmers和Category Theory in Context.\nMonads in Haskell 首先回顾一下Haskell中的monad。\nHaskell中的Monad m是一个typeclass，他本身是一个函子（因此m :: * -\u0026gt; *），带有一些满足特殊性质的运算。\n在Haskell中对monad有三种等价的定义，分别使用fish, bind, join配合return.\nfish🐟 对于category $C$和endofunctor $m$，我们可以将a到b的morphisms换成$a\\to m\\ b$的函数（这样的函数称为Kleisli arrows）， 若可以定义满足条件的composition和identity morphism，得到的新范畴就是$C$对应的Kleisli category $K$ ，此时称$m$是一个monad。\n在haskell中是这样定义的：\nclass Monad m where (\u0026gt;=\u0026gt;) :: (a -\u0026gt; m b) -\u0026gt; (b -\u0026gt; m c) -\u0026gt; (a -\u0026gt; m c) return :: a -\u0026gt; m a  注意到\u0026gt;=\u0026gt;(fish operator)就是composition，return是identity morphism（的polymorphic版本）。\n此时monad laws反应的就是Kleisli category对composition的要求：\nreturn \u0026gt;=\u0026gt; f = f -- left unit f \u0026gt;=\u0026gt; return = f -- right unit (f \u0026gt;=\u0026gt; g) \u0026gt;=\u0026gt; h = f \u0026gt;=\u0026gt; (g \u0026gt;=\u0026gt; h) -- associativity  bind 观察到\u0026gt;=\u0026gt;第一步必定是将a -\u0026gt; m b作用于a，因此可以将第一个a -\u0026gt; m b换成m b，简化得到\u0026gt;\u0026gt;=（bind），这是haskell中标准的monad的定义：\nclass Monad m where (\u0026gt;\u0026gt;=) :: m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b return :: a -\u0026gt; m a (\u0026gt;\u0026gt;) :: m a -\u0026gt; m b -\u0026gt; m b m \u0026gt;\u0026gt; k = m \u0026gt;\u0026gt;= (\\_ -\u0026gt; k)  直观上，bind将一个有context的value给了一个a -\u0026gt; m b类型的函数，他提供了一种“从context里拿出值”的方法。\n与fish互相表示：\nf \u0026gt;=\u0026gt; g = \\x -\u0026gt; f x \u0026gt;\u0026gt;= g x \u0026gt;\u0026gt;= f = ((\\_ -\u0026gt; x) \u0026gt;=\u0026gt; f) () -- one possible version  可以将fish表示的monad laws转换为等价的bind表示的monad laws：\nreturn x \u0026gt;\u0026gt;= f = f x mx \u0026gt;\u0026gt;= return = mx (mx \u0026gt;\u0026gt;= f) \u0026gt;\u0026gt;= g = mx \u0026gt;\u0026gt;= (\\x -\u0026gt; f x \u0026gt;\u0026gt;= g) -- 或者写成(m \u0026gt;\u0026gt;= \\x -\u0026gt; f x) \u0026gt;\u0026gt;= g = m \u0026gt;\u0026gt;= (\\x -\u0026gt; f x \u0026gt;\u0026gt;= g)更清楚一点  join 观察到我们可以借助fmap来应用函数f，因此只要一个join :: m(m a) -\u0026gt; m a就可以实现bind的功能：\nclass Functor m =\u0026gt; Monad m where join :: m (m a) -\u0026gt; m a return :: a -\u0026gt; m a  与bind互相表示：\nx \u0026gt;\u0026gt;= f = join (fmap f x) join x = x \u0026gt;\u0026gt;= id  join表示的monad laws在下文中会从Category Theory中对$\\eta,\\mu$的要求中推出，可以验证这两条和之前的monad laws等价。\ndo notation do实际上是一个syntactic sugar:\ndo {x1 \u0026lt;- m1; x2 \u0026lt;- m2; f x1 x2} = m1 \u0026gt;\u0026gt;= \\x1 -\u0026gt; m2 \u0026gt;\u0026gt;= \\x2 -\u0026gt; f x1 x2  可以类似命令式来写函数式。\n上述monad laws用do notation表示的话就是：\ndo {x' \u0026lt;- return x; return x'} = do {f x} do {x \u0026lt;- mx; return x} = do {mx} do {y \u0026lt;- do {x \u0026lt;- mx; f x}; g y} = do {x \u0026lt;- mx; y \u0026lt;- f x; g y}  Monads in Category Theory 在Category Theory中，monad的形式化定义如下：\n[Def] A monad on a category $C$ consists of:\n an endofunctor $T:C\\to C$ a multiplication natural transformation $\\mu : T^2 \\Rightarrow T$ a unit natural transformation $\\eta : 1_C\\Rightarrow T$  Coherence conditions: the following diagrams commute\n我们假设Haskell有一个Hask范畴（objects是type，morphims是functions）的话，Haskell中的monad就是Hask范畴上的monad，其中return就是$\\eta$，join就是$\\mu$（准确的说是components $\\eta_a,\\mu_a$的polymorphic版本），他们需要满足的monad laws就是$\\eta,\\mu$的两个图交换：\n $\\mu \\circ T \\mu = \\mu \\circ \\mu T$ : join . fmap (join) = join . join $\\mu \\circ T \\eta = \\mu \\circ \\eta T = 1_T$ : join . fmap (unit) = join . unit = id  当然$\\eta,\\mu$还要满足作为自然变换的coherence conditions，不过这两个条件由于Theorems for Free而自动满足：\n return . f = fmap f . return join . fmap (fmap f) = fmap f . join  所以Haskell中的monad与Category Theory中的monad是一致的，接下来只要解释Category Theory中monad为什么是a monoid in the endofunctor category. 我们需要先补充一些Category Theory中的概念。\nMonoid and Monoidal Category Monoid 经典的monoid（幺半群）是在集合上定义的，人如其名，有乘法运算和单位元。\n[Def] A monoid is an object $M\\in Set$ together with two morphisms $\\mu : M\\times M\\to M$ and $\\eta :1\\to M$.\nCoherence conditions: the following diagrams commute\n这个定义和抽象代数中是等价的，$\\mu$给出了一个二元运算并满足结合律（图1），$\\eta$给出了一个单位元（图2）。\n我们可以把monoid从Set上推广到其他category上，能在上面定义monoid的category需要满足一定条件，称为monoidal category。\nMonoidal Category 直观上，要想在一个category上定义monoid，这个category需要有一个objects之间的product，还要能从每个objects中拿出一个unit element。我们不能从category的objects里拿东西，但可以利用terminal object到其他objects的映射来取单位元，所以这个category要有一个类似terminal object的东西。。\nmonoidal category的形式化定义如下：\n[Def] A symetric monoidal category$(V,\\otimes,*)$ is a category $V$ together with:\n a bifunctor $-\\otimes-:V\\times V\\to V$ called monoidal product (or tensor product) a unit object $*$.  Coherence conditions: three coherence natural isomorphisms\nRemarks:\n  注意$\\alpha$这些natural isomorphisms是multifunctors之间的，他的components是$\\alpha_{u,v,w}$\n  三个coherence conditions分别是symetric, associativity, unit conditions on the monoidal product. 只满足后两个的话称为monoidal category\n  如果这些natural isomorphisms可以取identity natural isomorphisms的话，称为strict monoidal category.\n  Examples:\n All categories with ﬁnite products such as $(Set,\\times, * ), (Top,\\times,*),(Cat,\\times,1)$, where the monoidal unit in each case is the terminal object. 对偶地，finite coproduct和initial object也构成symmetric monoidal category，如$(Set,+,{})$. Hask范畴可以近似看成Set，因此product（coproduct）在同构意义下满足条件，terminal object是()（Empty），因此Hask是monoidal category。 A commutative monoid看作discrete category(即只有identity morphisms)的话也定义了一个symetric monoidal category，此时natural isomorphisms就是identities。另一方面，经典的monoid就是Set上的monoid。  Monoid in a Monoidal Category 在monoidal category$(V,\\otimes,*)$上定义monoid，我们需要取一个object $M\\in V$以及两个morphisms $\\mu : M\\otimes M\\to M$, $\\eta : * \\to M$. Coherence conditions和经典monoid相同。\nMonad as a Monoid 终于来到了正题。实际上经过前面的铺垫，剩下的内容就很简单了：\n我们考虑functor category $C^C$，它的objects是functors，morphisms是natural transformations。它是一个strict monoidal category，monoidal product是composition between functors，unit object是identity endofunctor。注意此时composition(一般省略运算符) $-\\circ -:C^C \\times C^C \\to C^C$是一个bifunctor，它是可以作用于natural transformation的，作用效果就是natural transformation的horizontal composition。\n那么$C^C$上的monoid是什么样的呢？取object $T\\in C^C$，morphisms $\\mu,\\eta\\in C^C$满足条件。 $T$就是一个monad！所以A monad on $C$ is a monoid in the monoidal category $C^C$ of endofunctors on $C$. Bingo!\n后记 其实这篇文章一点也不友好，只能作为给自己看的复习笔记。\nmonad相关还有好多有趣的内容，比如comonad、adjunctions等等，有时间一定写。\n希望以后多更新一点有趣的东西（喂至少做到月更啊\n","date":1598106327,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598106327,"objectID":"940448171a902c17fdfb515758a4226a","permalink":"thwfhk.github.io/post/monad_is_a_monoid/","publishdate":"2020-08-22T22:25:27+08:00","relpermalink":"thwfhk.github.io/post/monad_is_a_monoid/","section":"post","summary":" All told, monad is just a monoid in the category of endofunctors.\n","tags":["Haskell","Category Theory"],"title":"Monad是自函子范畴上的幺半群","type":"post"},{"authors":null,"categories":["科普向"],"content":" 爱情其实就是阿妮玛/阿尼姆斯在对方身上的投射。\n 这是一篇科普小短文，尽量使用了通俗易懂的语言来描述，希望能给读者带来一点乐趣！\n 下面开始正文：\n生活中有一种常见的情景：“Alice很喜欢Bob，想要向Bob表白，但是又害怕对方不喜欢自己而引起尴尬。”\n很多人都会陷入这种两难（dilemma）中，那么有什么办法可以在不暴露自己是否喜欢对方的前提下得知对方是否喜欢自己呢？\n一个简单的做法是，Alice和Bob分别告诉Carol自己是否喜欢对方，然后Carol同时告诉Alice和Bob你们是否相互喜欢对方。但是这种方法有一个明显的问题：你可能并不想让Carol知道自己的心意。\n那有没有更安全的方法呢？\n当然是有的。事实上，我们可以做到“Alice和Bob可以得知两人是否互相喜欢对方，并且自己是否喜欢对方这个信息不会被泄露给任何一个人”（当然了，“最后结果是相互喜欢”这种泄露不算）。并且，这一过程只需要交谈和2以内的加法乘法就可以完成，无需借助计算机等设备。\n一种安全的方法 为了表达方便，下面所有的数都要么是0要么是1，并且定义运算\\(x\\land y = x\\times y,\\ x\\oplus y = (x+y) \\bmod 2\\)（\\(\\bmod 2\\)表示除2取余数），实际上就是二进制的and运算和xor运算。\nAlice手里有一个数\\(x\\)，如果Alice喜欢Bob，那么\\(x=1\\)，否则\\(x=0\\)；同样的，Bob手里也有一个数\\(y\\)，如果Bob喜欢Alice，那么\\(y=1\\)，否则\\(y=0\\)。\n Alice将\\(x\\)任意拆成\\(x=x_1\\oplus x_2\\)；同样的，Bob也将\\(y\\)任意拆成\\(y=y_1\\oplus y_2\\)。\n Alice将\\(x_1\\)留下，\\(x_2\\)告诉Bob；类似的，Bob将\\(y_2\\)留下，\\(y_1\\)告诉Alice。此时Alice知道\\(x_1,y_1\\)，Bob知道\\(x_2,y_2\\)。\n 需要有一个第三方Carol，Carol要随机想好一个等式\\(c=a\\land b\\)，然后将\\(c,x,y\\)分别拆成\\(c=c_1\\oplus c_2,\\ a=a_1\\oplus a_2,\\ b=b_1\\oplus b_2\\)；将\\(a_1,b_1,c_1\\)告诉Alice，\\(a_2,b_2,c_2\\)告诉Bob，Carol的任务就完成了。\n Alice计算\\(e_1=a_1\\oplus x_1,\\ f_1=b_1\\oplus y_1\\)；同样的，Bob计算\\(e_2=a_2\\oplus x_2,\\ f_2=b_2\\oplus y_2\\)。 Alice和Bob将\\(e_1,f_1\\)和\\(e_2,f_2\\)告诉对方，一起计算\\(e=e_1\\oplus e_2,\\ f=f_1\\oplus f_2\\)。 Alice计算\\(z_1 = (f\\land a_1)\\oplus (e\\land b_1)\\oplus c_1\\)；同样的，Bob计算\\(z_2 = (f\\land a_2)\\oplus (e\\land b_2)\\oplus c_2\\)。 最后，Alice和Bob将\\(z_1\\)和\\(z_2\\)告诉对方，一起计算出\\(z=z_1\\oplus z_2\\)，我们就完成了！如果\\(z=1\\)，说明Alice和Bob互相喜欢；如果\\(z=0\\)，说明Alice和Bob当中至少有一个人不喜欢对方。\n  原理是什么？ 实际上，我们刚才的过程就是在“双方安全的计算两个数的乘积”，只不过是在模2意义下的单bit形式。\n这个问题属于多方安全计算(Secure Multi-Party Computation)领域，刚才的过程实际上通过一种叫做秘密共享(Secret Sharing)的方法完成的。\n直观上，Alice秘密就是\\(a\\)，然后Alice将他/她的秘密的一部分\\(a_2\\)分享给了Bob；Bob也是同理。\n更具体的解释，可以自行Google，或者参考ABY–A Framework for Efficient Mixed-Protocol Secure Two-Party Computation这篇文章的第三部分。\n它真的正确吗？ 是真的。不信的话，你可以马上找身边的人陪你玩一下。\n它真的安全吗？ 只要你不把不该告诉对方的东西说出去，它就是安全的。\n当然了，如果Carol和对方串通一气的话就不好了。\n事实上，Carol并不是必须的，我们可以通过Homomorphic Encryption(HE)或者Obilivious Transfer(OT)的方法来计算这个multiplication triple \\((c_1\\oplus c_2)= (a_1\\oplus a_2)\\land (b_1\\oplus b_2)\\)。然而，HE和OT并不是能手算的东西。并且既然都HE了，直接用HE来安全的计算\\(x\\land y\\)不好吗🙃\n后记 遇到生活中有趣的问题，还能与近期学的一些知识产生联系的概率真的很小QwQ。\n希望这个系列能活下去...\n","date":1589593786,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589593786,"objectID":"a5c49233f1616eb13ca0a157ec6fed80","permalink":"thwfhk.github.io/post/do_u_like_me/","publishdate":"2020-05-16T09:49:46+08:00","relpermalink":"thwfhk.github.io/post/do_u_like_me/","section":"post","summary":" 爱情其实就是阿妮玛/阿尼姆斯在对方身上的投射。\n","tags":["secret sharing","writing"],"title":"如何安全地知道对方是否喜欢你","type":"post"},{"authors":null,"categories":["What-is-what"],"content":" 0,1,2,3,4,....我好像可以无穷无尽的数下去啊？\n 这是\u0026quot;什么是什么(What is What)\u0026quot;系列的第一篇文章，首先介绍一下这个系列：\n我有时会发现自己在不同的地方学到的东西以某种微妙的方式联系在一起，这种体验非常有趣；另一方面，有些事物又是难以界定的，即使读再多次它的定义，仍会感到琢磨不透。因此，我希望开始这样一个系列，将我在不同的地方看到的同一事物总结在一起，希望能够发现它们之间的某种联系，从而对事物本身有更清晰的认识。\n第一个事物是“自然数(Natural Numbers)”.\n1. 自然语言  来自日常生活和中学数学。\n 自然数就是0,1,2,3,4,...这样数下去得到的所有的数。\n自然数就是所有的正整数，包含0.（PS: 我至今记得高中时我分不清\\(\\mathbb{N}\\)中有没有0，然后同桌一脸鄙夷的说“N是自然数的缩写吧，应该包含0”）\n2. Peano公理  来自Discrete Math课程。\n Peano公理刻画了自然数集的性质，满足Peano公理的系统是自然数集（至少是和自然数集同构的）。\n一种Peano公理的描述为：设三元组\\((N,F,0)\\)满足：\n\\(0\\in N\\)\n \\(N\\) is closed under \\(F\\), i.e. \\(F(N)=\\{F(n)\\mid n\\in N\\} \\subset N\\)\n \\(0\\notin \\text{ran}\\ F\\)\n \\(F\\) is injective.\n Suppose a subset \\(A\\) of \\(N\\) satisfies \\(0\\in A\\) and \\(F(A)\\subset A\\), then \\(A=N\\).\n  这样\\(N\\)就是自然数集。\n事实上，\\(F\\)指定了\\(N\\)上的一种“后继”运算，这种后继运算给了\\(N\\)中每个元素一个独一无二的后继，并且每个后继都在\\(N\\)中，这和自然数是相符的。第5条可以算是“最关键”的一条，它实际上说明了自然数集\\(N\\)是满足这个条件的最小集合。\n3. 集合论(Set Theory)  来自Discrete Math课程。\n 自然数集是最小的归纳集(minimal inductive set).\n其中一个集合\\(A\\)是归纳集(inductive set)，当且仅当：\n \\(0\\in A\\) \\(\\forall a\\in A,\\ a^+\\in A\\)  其中\\(a^+\\)是\\(a\\)的后继运算。\n可以发现，这种定义和Peano公理几乎是一样的，\\(a^+\\)就是\\(F(a)\\)。Peano公理中的第5条实际上就是保证了\u0026quot;\\(N\\)是满足\\(0\\in A\\land F(A)\\subset A\\)的最小集合\u0026quot;。\n另外，在集合论中有一种对自然数的经典构造：\n \\(0=\\{\\}\\) \\(1=\\{0\\} = \\{\\{\\}\\}\\) \\(2=\\{0,1\\}=\\{\\{\\},\\{\\{\\}\\}\\}\\) ... \\(n+1 = n\\cup \\{n\\}\\)  这种构造的一个好处在于\\(a\\le b\\)可以表达成\\(a\\subseteq b\\)。\n4. 不动点(Fixed Point)  来自Types and Programming Languages.\n 自然数集是函数\\(F\\)的最小不动点(the least fixed point)，其中集合到集合的函数\\(F\\)定义为：\n \\(F(X) = \\{0\\}\\cup \\{x^+\\mid x\\in X\\}\\)  \\(F\\)的不动点是指满足\\(X=F(X)\\)的集合\\(X\\)。\n这个定义在本质上和前面是一样的，只不过是从不动点的角度。\n最小不动点和最大不动点构造常用来定义程序语言中的recursive datatypes，这里实际上将“自然数集”看成了“自然数类型”这个递归数据类型。\n更多信息可以参考Types and Programming Languages的21章。\n5. F-代数(F-Algebra)  来自Program Calculation.\n 记\\(F=\\underline 1\\hat{+} Id\\)，\\(Nat = \\mu F\\)，即自然数集是函子\\(F\\)的初始代数的Carrier。\\((Nat,in_F::F\\ \\mu F\\to\\mu F)\\)是F-初始代数(the initial \\(F\\)-algebra)。\n这种使用intial F-algebra来定义的数据类型又叫做Algebraic Datatypes.\n这里使用\\(Nat\\)而不是\\(\\mathbb{N}\\)，是为了看起来更像一个数据类型，而不是自然数集合。虽然在使用\\(Set\\)范畴的时候，他们是一样的。\nThe initial \\((\\underline 1\\hat{+} Id)\\)-algebra 意味着在某种意义上，\\(Nat\\)是函子\\((\\underline 1\\hat{+} Id)\\)的“最小不动点”，即满足\\(Nat = 1+Nat\\)的最小集合。\n在Program Calculation中借用了范畴论的一些概念，这里不严格的稍作解释：我们取\\(Set\\)范畴，可以认为\\(Set\\)中每个object都是一个类型，每个arrow都是函数（\\(f:A\\to B\\)将类型\\(A\\)的元素映射到类型\\(B\\)的元素）。自函子(endo-functor)就是范畴到自身的映射，将objects和arrows映射到objects和arrows。我们考虑一个自函子\\(F\\)，它的F-algebra定义为一个pair \\((A,f),\\ f::F\\ A \\to A\\) ，\\(A\\)是\\(Set\\)中的一个object。Initial F-algebra 就是\\((\\mu F, in_F)\\)，满足从\\((\\mu F, in_F)\\)到任何其他F-algebra \\((A,f)\\)都有一个homomorphism。利用initial F-algebra以及和它对偶的final F-algebra这两种构造，可以形式化的描述fold(catamorphism)和unfold(anamorphism)。\n更严格的描述可以参考Calculating Functional Programs或者其他有关Program Calculation的材料。\n与自然数上递归定理的联系 顺便提一下，使用F-algebra定义的自然数自带了到其他F-algebra的唯一同态，而这与自然数上的递归定理产生了某种联系：\n先回顾一下自然数上的递归定理：\n 设集合\\(A,\\ a\\in A,\\ F:A\\to A\\)，则存在唯一的\\(h:\\mathbb{N}\\to A\\)，满足 \\(h(0)=a\\) 且 \\(\\forall n\\in \\mathbb{N},\\ h(n^+) = F(h(n))\\)。  写成point-free就是\\(h\\circ succ = F\\circ h\\)，其中\\(succ(n) = n^+\\)\n而由于\\((\\mathbb{N},zero\\triangledown succ)\\)是一个initial \\((\\underline 1\\hat{+} Id)\\)-algebra，所以从它到任何其他\\((\\underline 1\\hat{+} Id)\\)-algebra \\((A,f)\\)存在唯一的同态\\(h:\\mathbb{N}\\to A\\)，满足\\(h\\circ (zero\\triangledown succ) = f\\circ (1+h)\\)\n啊哈，实际上“\\(h\\circ (zero\\triangledown succ) = f\\circ (1+h)\\)” 和 “\\(h(0)=a\\) 且 \\(\\forall n\\in \\mathbb{N},\\ h(n^+) = F(h(n))\\)” 这两个描述的性质是一模一样的！\n这么说，“自然数上的递归定理” 描述的就是 “从一个初始F-代数到其他F-代数的同态”！这个同态其实就是fold(catamorphism)！想要计算\\(h(n)\\)，实际上就是将n中的0换成\\(a\\)，\\(^+\\)换成\\(F\\)。\n从这里推广，对于任意一个algebraic datatype，我们都可以得到一个类似的“递归定理”，实际上就是catamorphism。\n后记 其实本来是读Calculating Functional Programs想到的这个问题，回顾了一下Discrete Math后发现原来还有这么多联系，非常有趣。\n","date":1589430360,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589430360,"objectID":"28ba4b2b9dda555c34879b9c7d83d51c","permalink":"thwfhk.github.io/post/natural_numbers/","publishdate":"2020-05-14T12:26:00+08:00","relpermalink":"thwfhk.github.io/post/natural_numbers/","section":"post","summary":" 0,1,2,3,4,....我好像可以无穷无尽的数下去啊？\n","tags":["Set Theory","Category Theory","Programming Language Theory"],"title":"什么是自然数","type":"post"},{"authors":null,"categories":[],"content":"今天的信息论课上讲Kolmogorov Complexity的时候提到了停机问题(Halting Problem)的一点内容，其中有讲到停机问题的证明。\nCandy?发现停机问题的证明和上学期离散数学课程学到的康托定理(Cantor's Theorem)的证明非常像，于是思考了一下他们之间的联系，总结如下，以求赶在三月末尾水一篇博客。如有错误欢迎指出。\nCantor's Theorem 康托定理说的是“任何集合和它的幂集不等势”，也就是说\\(A \\not\\approx P(A)\\)。\nProof: 反证，假设\\(\\exists f:A\\to P(A)\\) 是一个双射。\n考虑 \\(B=\\{x:x\\in A \\land x\\notin f(x)\\} \\in P(A)\\)。设 \\(f(x_0) = B\\)，考虑\\(x_0\\)是否在\\(B\\)集合内：\n 若\\(x_0 \\in B\\)，则有\\(x_0 \\notin f(x_0) = B\\)，产生矛盾； 若\\(x_0\\notin B\\)，则有\\(x_0 \\in f(x_0) =B\\)，产生矛盾。  所以并不存在这样的双射\\(f\\)。\nHalting Problem 停机问题是说，对于程序\\(P\\)在输入\\(I\\)下的计算过程\\(P(I)\\)，其是否会在有限步终止是不可计算的。\n经典的证明方法是这样的：\n反证，假设\\(\\exists\\ \\text{program}\\ H\\)可以判定是否会停机，即 \\[ H(P,I) = \\begin{cases} h \u0026amp; \\textrm{if $P(I)$ halts in finite steps},\\quad \\\\ l \u0026amp; \\textrm{if $P(I)$ loops forever}\\\\ \\end{cases} \\] 考虑program \\(K\\)， \\[ K(P) \\begin{cases} \\text{halts in finite steps} \u0026amp; \\textrm{if $H(P,P) = l$},\\quad \\\\ \\text{loops forever} \u0026amp; \\textrm{if $H(P,P)=h$}\\\\ \\end{cases} \\] 考虑\\(H(K,K)\\)的结果：\n 若\\(H(K,K)=h\\)，即\\(K(K)\\) halts，由\\(K(P)\\)定义有\\(H(K,K)=l\\)，产生矛盾； 若\\(H(K,K)=l\\)，即\\(K(K)\\) loops forever，由\\(K(P)\\)定义有\\(H(K,K)=h\\)产生矛盾。  所以不存在这样的program \\(H\\)。\n它们之间的联系 直觉上这两个证明是非常像的。\n实际上，可以改写Halting Problem的证明，得到和Cantor's Theorem的证明相似的形式：\n同样假设\\(\\exists\\ \\text{program}\\ H\\)可以判定是否会停机。设所有program的集合是\\(A\\)（这个集合是良定义的，毕竟\\(A=\\Sigma^*\\)加上一个确定的语法检查过程），对于\\(\\forall P\\in A\\)，可以定义集合\\(f(P) = \\{I : P(I)\\ \\text{halts in finite steps}\\}\\)。\\(f\\)是一个\\(A\\to P(A)\\)的映射。\n考虑\\(B=\\{P:P\\in A \\land P \\notin f(P)\\}\\)。容易发现\\(B = \\{P:P\\in A \\land H(P,P) = l\\}\\)。\n同样定义program \\(K\\)： \\[ K(P) \\begin{cases} \\text{halts in finite steps} \u0026amp; \\textrm{if $H(P,P) = l$},\\quad \\\\ \\text{loops forever} \u0026amp; \\textrm{if $H(P,P)=h$}\\\\ \\end{cases} \\] 容易验证\\(f(K) = B\\)，考虑\\(K\\)是否在\\(B\\)集合内：\n 若\\(K \\in B\\)，则有\\(K \\notin f(K) = B\\)，产生矛盾； 若\\(K\\notin B\\)，则有\\(K \\in f(K) =B\\)，产生矛盾。  所以不存在这样的program \\(H\\)。\n现在这个证明就和Cantor's Theorem的证明一模一样了！\n这个改写的核心就是，将原来的判断\\(H(P,P) = l\\)，变成判断\\(P \\in B\\)。\n还有一点值得注意的地方：\n Cantor's Theorem的矛盾点是“\\(f\\)不是双射”，而这个证明的矛盾点是“\\(H\\)不存在”。其实这里是一致的，Cantor's Theorem的证明中\\(f\\)是双射保证了能找到\\(f^{-1}(B) = x_0\\)，而这个证明中\\(H\\)存在保证了能找到\\(f^{-1}(B)=K\\)。 在某种意义上“\\(H\\)存在”是比“\\(f\\)是双射”弱的，因为\\(H\\)的存在只能找到\\(B\\)在映射下的逆，对于任意\\(S \\in P(A)\\)不一定有\\(f^{-1}(S)\\)的存在。  后记 本来还想：如果有验证停机问题的程序\\(H\\)，就能得到\\(A\\to P(A)\\)的双射了，结果发现想的不对。程序和(数学中)函数这两个概念还是要好好区分的，函数更强大，而程序只能算是函数的一个子集，只能给出某个可计算问题所对应的映射。\n另外，停机问题还与lambda calculus、哥德尔定理等等有紧密的联系，发现了一篇不错的blog。恰好最近在上DPPL，对lambda calculus比较感兴趣，有时间仔细研究一下。(咕咕咕)\n","date":1585666523,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585666523,"objectID":"af0250414f50478bf1995eef316c2fe3","permalink":"thwfhk.github.io/post/halting_problem_and_cantor_theorem/","publishdate":"2020-03-31T22:55:23+08:00","relpermalink":"thwfhk.github.io/post/halting_problem_and_cantor_theorem/","section":"post","summary":"今天的信息论课上讲Kolmogorov Complexity的时候提到了停机问题(Halting Problem)的一点内容，其中有讲到停机问题的证明。\n","tags":["Computation Theory","Set Theory"],"title":"停机问题与康托定理","type":"post"},{"authors":null,"categories":[],"content":"Candy?在上学期的数算课上学了红黑树，但是他一直没写过。\n最近他入门了一下Haskell，得知用Haskell可以很方便实现各种树结构，于是就去学了一下如何用Haskell写红黑树，发现只要不到60行！（包括空行和类型签名）\n下面是一个简单的小教程。\nPS: 其实下面的算法和数算学的那个一点关系都没有\n定义类型 和普通二叉树一样哒，只不过加上了一个颜色信息\ndata Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq) data Color = R | B deriving (Show, Eq)  辅助函数  将树根染黑：  makeBlack :: Tree a -\u0026gt; Tree a makeBlack Nil = Nil makeBlack (Node _ l x r) = Node B l x r   将树根染红：  makeRed :: Tree a -\u0026gt; Tree a makeRed Nil = Nil makeRed (Node _ l x r) = Node R l x r  插入操作 一般的红黑树插入不太方便用纯函数式来写，Okasaki在1999年提出了一种新的插入方法，将插入统一为：\n 首先默认插入红色节点，然后从下向上进行balance操作； balance操作会处理当前子树的children和grandchildren出现双红的情况，并且会将当前子树的根变红（balance操作并不会改变rank）  插入操作的框架很简单，需要注意的是最后要让整棵树的根变黑：\ninsert :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a insert x = makeBlack . ins where ins Nil = Node R Nil x Nil ins t@(Node c l y r) | x \u0026lt; y = balance $ Node c (ins l) y r | x \u0026gt; y = balance $ Node c l y (ins r) | otherwise = t  balance操作要处理四种情况：\n可以方便的用pattern matching来实现：\nbalance :: Tree a -\u0026gt; Tree a balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d) balance t@(Node c x l r) = t  删除操作 插入操作只要处理“双红”，删除操作还要处理“黑色节点数相等”，比较麻烦。\n这里采用了Stefan Kahrs在2001年提出的方法，主要特点是：\n 不将待删除节点与后继交换 维持一个新的invariant：  从黑根子树中删除节点，该子树高度会-1 从红根子树中删除节点，该子树高度不变    我们有balanceL和balanceR两个操作，分别处理“左子树比右子树短1”和“右子树比左子树短1”的情况，将整棵树的高度变成较短那个的状态。\n删除操作的框架如下：\ndelete :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a delete x = makeBlack . del where del Nil = Nil del t@(Node _ l y r) | x \u0026lt; y = delL t | x \u0026gt; y = delR t | otherwise = app l r delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r delL (Node _ l y r) = Node R (del l) y r delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r) delR (Node _ l y r) = Node R l y (del r)  以待插入节点将插入左子树为例：\n 当前节点y的左子树为黑根时，会在删除后将y染黑并进行balanceL操作 当前节点y的左子树为红根时，会在删除后将y染红  容易发现，这样操作是可以维持新的invariant的（枚举当前节点颜色情况证明即可）\n由于delete中在balanceL/R之前会染黑，balanceL/R只要处理根为黑的情况即可，有三种情况：\n同样用pattern matching来实现：\nbalanceL :: Tree a -\u0026gt; Tree a balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b) balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c)) balanceR :: Tree a -\u0026gt; Tree a balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b) balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r)  app会合并两个子树，有三种情况：\n同样用pattern matching来实现：\napp :: Tree a -\u0026gt; Tree a -\u0026gt; Tree a app Nil t = t app t Nil = t app (Node R a x b) (Node R c y d) = case app b c of Node R b' z c' -\u0026gt; Node R (Node R a x b') z (Node R c' y d) s -\u0026gt; Node R a x (Node R s y d) app (Node B a x b) (Node B c y d) = case app b c of Node r b' z c' -\u0026gt; Node R (Node B a x b') z (Node B c' y d) s -\u0026gt; balanceL $ Node B a x (Node B s y d) app (Node R a x b) t = Node R a x (app b t) app t (Node R a x b) = Node R (app t a) x b  完整代码 只要60行！\ndata Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq) data Color = R | B deriving (Show, Eq) makeBlack :: Tree a -\u0026gt; Tree a makeBlack Nil = Nil makeBlack (Node _ l x r) = Node B l x r makeRed :: Tree a -\u0026gt; Tree a makeRed Nil = Nil makeRed (Node _ l x r) = Node R l x r insert :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a insert x = makeBlack . ins where ins Nil = Node R Nil x Nil ins t@(Node c l y r) | x \u0026lt; y = balance $ Node c (ins l) y r | x \u0026gt; y = balance $ Node c l y (ins r) | otherwise = t balance :: Tree a -\u0026gt; Tree a balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d) balance t@(Node c x l r) = t delete :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a delete x = makeBlack . del where del Nil = Nil del t@(Node _ l y r) | x \u0026lt; y = delL t | x \u0026gt; y = delR t | otherwise = app l r delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r delL (Node _ l y r) = Node R (del l) y r delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r) delR (Node _ l y r) = Node R l y (del r) balanceL :: Tree a -\u0026gt; Tree a balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b) balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c)) balanceR :: Tree a -\u0026gt; Tree a balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b) balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r) app :: Tree a -\u0026gt; Tree a -\u0026gt; Tree a app Nil t = t app t Nil = t app (Node R a x b) (Node R c y d) = case app b c of Node R b' z c' -\u0026gt; Node R (Node R a x b') z (Node R c' y d) s -\u0026gt; Node R a x (Node R s y d) app (Node B a x b) (Node B c y d) = case app b c of Node r b' z c' -\u0026gt; Node R (Node B a x b') z (Node B c' y d) s -\u0026gt; balanceL $ Node B a x (Node B s y d) app (Node R a x b) t = Node R a x (app b t) app t (Node R a x b) = Node R (app t a) x b  其他API 一些其他常规操作的API：序列和树之间转换、查找、求后继\ntree2List :: Tree a -\u0026gt; [a] tree2List Nil = [] tree2List (Node c l x r) = tree2List l ++ [x] ++ tree2List r list2Tree :: Ord a =\u0026gt; [a] -\u0026gt; Tree a list2Tree = foldl (flip insert) Nil search :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Bool search _ Nil = False search x (Node _ l y r) | x == y = True | x \u0026lt; y = search x l | otherwise = search x r successor :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; a successor x Nil = x successor x (Node _ l y r) | x \u0026lt; y = let t = successor x l in if x == t then y else t | x \u0026gt;= y = successor x r  PS：因为没有维护size信息所以没法求第k小QwQ，不过加上size信息应该也不难写。\n参考资料  一篇讲的很好的博客 一份代码实现 Kahrs, Stefan. (2001). Red-black trees with types. Journal of Functional Programming. 11. 10.1017/S0956796801004026. 另外，Matt Might提出了一种更加简洁的删除操作的实现，详情参阅他的博客。 ","date":1581406306,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581406306,"objectID":"5f20355a85287cd3690888fbf3394aa4","permalink":"thwfhk.github.io/post/haskell_red_black_tree/","publishdate":"2020-02-11T15:31:46+08:00","relpermalink":"thwfhk.github.io/post/haskell_red_black_tree/","section":"post","summary":"Candy?在上学期的数算课上学了红黑树，但是他一直没写过。\n","tags":["Haskell","Algorithm"],"title":"如何用Haskell写一棵红黑树","type":"post"},{"authors":null,"categories":[],"content":"故事是这样开始的：\n今天下午ICS课的时候昕神跟我说：“国庆节不会要放两个lab吧，国庆放几天啊”。\n我看了一下校历，“从9月28号到10月6号，28、29、30、31，加6天，10天吧”\n“你怎么判断9月的大小的啊？”，昕神这时还在数手指关节判断大月小月。\n“奥奥，9月是小月啊，那应该是9天”，我恍然大悟。\n“判断大小月好麻烦，不可以直接用奇偶性”\n“主要是因为7月8月连续是大月，当初设计的时候为什么不2月29天然后8月也是小月”\n 于是我开始查2月只有28天的原因。\n大多数中文资料都讲了这样一个故事：\n 凯撒修改后的历法中2月是29天的并且8月是30天，屋大维继位后，不满足于自己出生的8月份只有30天于是从2月中拿了一天到8月。\n 虽然非常具有戏剧性，但这个故事实在是太不可信，我又去google了一下，结果\n人家根本就不是8月出生的！（当然，有其他版本的故事说屋大维是8月获得奥古斯都的称号，所以将8月变成大月，但这也是不对的）\n有很多英文资料解释了这个原因，说法大致相同，概括来说就是：\n 罗马人最初到历法是月亮历，并且只有10个月，1月和2月没有命名，因为当时的罗马人觉得那段时间不重要（对耕种而言）。\n这10个月中有6个30天4个31天，共304天。\n后来罗马的第二个皇帝Numa将1月和2月加到了这10个月的最后，让总天数为355天。出于对“偶数不吉利”的认识，还将30天的月改成29天。这样一来，剩下57天分给两个月，必须让1个月是28天，于是就选择了最后一个2月。\n但是355天显然不对，于是加入了“闰月”制度。\n凯撒即位后将历法改革成太阳历，给一些月加了1到2天成了30天和31天，但保留了2月还是28天。\n 而那种错误的解释，可以追溯到13世纪Sacrobosco的解释，详情可见wiki中的说明。这个解释已经被许多史料证明是不对的。\n值得一提的是，在实行闰月制度的时候，人们也记不清是否闰月，都是由priests宣布的，所以就会产生滥用权力进行时间攻击的情况发生，比如“extend the terms of friends and trim the terms of enemies”，想想也是蛮酷的。\n 最后总结，这个故事告诉我们：放假真好！\n PS：今天晚上autolab真的修好了，第一个lab也发布了，due竟然是9月30号，然后我本周离散作业还没写，wysl😢\n","date":1569254000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569254000,"objectID":"21001c9f098ee925adee36f597ed0505","permalink":"thwfhk.github.io/post/february/","publishdate":"2019-09-23T23:53:20+08:00","relpermalink":"thwfhk.github.io/post/february/","section":"post","summary":"故事是这样开始的：\n今天下午ICS课的时候昕神跟我说：“国庆节不会要放两个lab吧，国庆放几天啊”。\n","tags":["Writing"],"title":"为什么2月只有28天","type":"post"},{"authors":null,"categories":[],"content":"My first blog This is my new home!\nthe second title 我爱中文！\n$$ \\sum_{k=1}^{\\infty} \\frac{1}{k} $$\nimport CandyQwQ CandyQwQ.sayhi()   走向隐晦和未知，要通过更为隐晦和未知的事物。\n ","date":1566644846,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1566644846,"objectID":"58bca268bba3f6f91e529ab15962c5b5","permalink":"thwfhk.github.io/post/first/","publishdate":"2019-08-24T19:07:26+08:00","relpermalink":"thwfhk.github.io/post/first/","section":"post","summary":"My first blog This is my new home! the second title 我爱中文！ $$ \\sum_{k=1}^{\\infty} \\frac{1}{k} $$ import CandyQwQ CandyQwQ.sayhi() 走向隐晦和未知","tags":["hello"],"title":"First","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"thwfhk.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"thwfhk.github.io/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"6a204204d85dda77db0dd5109fd73ae2","permalink":"thwfhk.github.io/project/lambdam/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"thwfhk.github.io/project/lambdam/","section":"project","summary":"A Simple Language with Termination Checking based on Dependent Types.","tags":["Programming Language"],"title":"LambdaM","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"4f75ccb9df9769d757f18b3f5cd19c10","permalink":"thwfhk.github.io/project/facial-filter/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/project/facial-filter/","section":"project","summary":"Implementation of a Real Time Facial Filter Software with GUI.","tags":["Algorithm"],"title":"Facial Filters","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ff6a19061a984819d30c916886db56ef","permalink":"thwfhk.github.io/publication/example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/publication/example/","section":"publication","summary":"","tags":null,"title":"I have no publication yet.","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"cd0c5139610e946632774a6f5a6a1e11","permalink":"thwfhk.github.io/project/subgraph-isomorphism/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/project/subgraph-isomorphism/","section":"project","summary":"Implementation and optimization of some algorithms for the subgraph isomorphism problem.","tags":["Algorithm"],"title":"Subgraph Isomorphism","type":"project"}]